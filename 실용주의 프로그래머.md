## 깨진 창문을 내버려 두지 말라.
> 더 이상의 손상을 예방하기 위해 어떤 조치든 취하고 여러분이 상황을 잘 관리하고 있음을 보여줘라.  

> 깨진 창문이 꽤 있는 프로젝트에서 일할 때는 '나머지 코드가 전부 쓰레기니까 나도 그렇게 하지 뭐.'라는 사고에 빠지기 너무 쉽다.


## '적당히 괜찮은'이라는 표현은 너절하거나 형편없는 코드를 의미하지 않는다.
> 사용자나 미래의 유지 보수 담당 아니면 자기 자신이 마음의 평화를 유지하기에 적당할 정도로 괜찮으면 된다. 여러분은 더 생산적이 되고 사용자는 한층 더 행복해 할 것이다.


## 재사용하기 쉽게 만들어라.
> 뭔가를 직접 만드는 것보다 기존의 것을 찾아내고 재사용하기 쉬운 환경을 조성해야 한다.

그래야 중복을 줄이기 쉽다.


## 관련 없는 것들 간에 서로 영향이 없도록 하라.
> 해당 컴포넌트의 외부 인터페이스를 바꾸지 않는 한 전쳬 시스템으로 퍼져 나가는 문제를 일으키지는 않으리라고 확신할 수 있다.
> 직교적인 시스템을 작성하면 두 가지 큰 장점이 있다. 바로 생산성 향상과 리스크 감소다.

직교적인 시스템을 작성한다는 말은 상대적으로 작게 응집된 코드들을 작성한다는 의미. 따라서 개발과 테스트, 그리고 재사용이 쉽기 때문에 생산성이 향상된다.  


## 실용주의 프로그래머는 예광탄을 활용한다.

동작하는 코드로 검증하기.  


## 범위로 추정하라.
낙관적 추정치, 가장 가능성이 높은 추정치, 비관적 추정치로 추정해보기.  
"빠르면 6시간, 늦으면 12시간 정도 걸릴 것 같아요."라고 답해보자.


## 모든 스위치/케이스 문에 default 구문을 달아라.

> '있을 수 없는 일'이 발생했을 때 우리는 그 사실을 알아야 한다.


## 헤드라이트를 앞서가지 말아라.
> 불확실한 미래에 대비한 설계를 하느라 진을 빼는 대신 언제나 교체 가능한 코드를 작성하여 대비하면 된다. 여러분의 코드를 더 적절한 무언가로 대체하기 쉽게 설계하라. 코드를 교쳬할 수 있도록 하면 응집도나 결합도, DRY에도 도움이 되고, 전반적으로 더 나은 설계가 탄생할 것 이다.

## 상속하지 마라.
대신 인터페이스, 위임, 믹스인을 사용하라.

1. 인터페이스  
implements 문법을 활용하는 것.  
반대로 상속은 extends 하는 것.  
extends하면 내가 정의하지 않은 프로퍼티나 메서드를 사용할 수 있기 때문.
```
class Car implements Vehicle { }
```

2. 위임  
   외부 api를 직접 쓰지 말고 wrapping 하는 것.
```
class Account {
  constructor(Persister) {
    this.repo = Persister
  }

  save {
    this.repo.save()
  }
}
```
이제 Account를 사용하는 쪽은 Persister에 직접 접근할 수 없다.  
즉, Account를 사용하는 쪽과 Persister의 결합이 사라진다.  

3. 믹스인  
   클래스를 혼합하는 것
   타입스크립트에선 별도 함수로 구현 가능

# 동시성
> '동시성concurrency'은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것이다. 그리고 '병렬성parallelism'이란 실제로 동시에 실행되는 것이다.

하나의 데이터에 둘 이상의 클라이언트가 접근할 때 동시성 이슈가 생길 수 있다. 
웹 프론트엔드의 경우, 한명의 유저가 여러 기기를 통해 접근할 때 발생할 수 있다.  
서버의 경우처럼 크리티컬하진 않지만 고려하면 좋을 것이다.  


### 문서화된 동작에만 의존하라. 그럴 수 없다면 추측을 문서로 남겨라.  
> 모든 차원에서 사람들은 마음속에 많은 가정을 품고 작업한다. 하지만 이런 가정을 문서화하는 경우는 드물며 개발자마다 가정이 다를 때도 많다. 확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.


### 성급한 최적화를 조심하라.
> 언제나 어떤 알고리즘을 개선하느라 여러분의 귀중한 시간을 투자하기 전예 그 알고리즘이 정말로 병목인지 먼저 확인하는 것이 좋다.
